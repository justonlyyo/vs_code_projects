# 操作系统

## 基本概念

操作系统四大特征:**并发性,共享性,虚拟性,不确定性**
操作系统的功能可分为5大部分

1. **进程管理**: 实质上是对处理及的执行'时间'进行管理.包含**进程控制,进程同步,进程通讯和进程调度**
2. **文件管理**: 包括**存储空间管理,目录管理,文件的读写管理和存取管理**
3. **存储管理**: 就是对主存的"空间"进行管理,包括**存储分配和回收,存储保护,地址映射和变换,主存扩充**
4. **设备管理**: 对硬件设备的管理.包括**输入/输出设备的分配,启动,完成和回收**
5. **作业管理**: 包括**任务,界面管理,人际交互,图形界面,语音控制和虚拟现实**

### 操作系统的分类

通常,操作系统可分为

* **批处理操作系统**,
* **分时操作系统**,
* **实时操作系统**,
* **网络操作系统**
* **分布式操作系统**,
* **微机操作系统**
* **嵌入式操作系统**

## 进程管理

进程管理又称处理机管理.在多道程序批处理系统和分时系统中有多个并发执行的程序,因此引入进程概念用来描述系统中程序执行时的动态变化的过程.进程是资源分配和独立运行的基本单位.进程管理的重点是研究进程间并发性, 合作和资源竞争问题

程序的顺序执行的主要特征包括顺序行,封闭性和可再现性.
程序并发执行的特征:

1. 失去了程序的封闭行
2. 程序和机器的执行程序的活动不再一一对应.
3. 并发程序间的相互制约

进程是程序的一次执行.程序可以和其他程序并发的执行.进程通常是由**程序,数据,进程控制(Process Control Block PCB)**组成.

1. PCB是进程存在的唯一标示
2. 程序部分描述了进程需要完成的功能.假如一个程序能被多个进程同时共享执行,那么这一部分就应该以可在如码的形式编制,它是程序执行时不可修改的部分
3. 数据部分包含程序执行时所需的数据和工作区.该部分只能为一个进程所专用.是进程的可修改部分

### 进程的状态

![进程的5态模型](image/进程的5态模型.png)

1. **活跃就绪**是值程序存在与主存并且可被调度的状态
2. **静止就绪**是指就绪进程被置换到辅存的状态.此状态不能被直接调度,可被转换为活跃就绪状态
3. **活跃阻塞**是指进程在主存,一旦等待的事件发生就转入活跃就绪状态.可被挂起为静止阻塞状态
4. **静止阻塞**是指阻塞的进程被置换到辅存的状态.一旦等待的事情发生,就会转入静止就绪状态.可被激活为活跃阻塞状态
5. **运行**是指程序正在运行的状态.1.如果一个时间片到,程序未执行完毕.那就会转入活跃就绪状态等待下一个时间片的到来(CPU调度).2.如果运行时,必要的资源未就绪.程序会转入活跃阻塞状态等待资源.3. 运行状态也可以被人为挂起到静止就绪状态

5个状态之间的关系如下

* 运行状态间的转换
>* 时间片到任务未完成,**运行转入活跃就绪**状态
>* 等待资源,**运行转入活跃阻塞**状态
>* 运行状态时被(人为)挂起,**运行转入静止就绪**状态
>* 活跃阻塞被(人为)挂起.**活跃阻塞转入静止阻塞**.
>* 活跃阻塞状态时,等待的资源满足.**活跃阻塞转入活跃就绪**.
>* 活跃就绪被被CPU调度.**活跃就绪转入运行**.
>* 活跃就绪被被(人为)挂起.**活跃就绪转入静止就绪**.
>* 静止阻塞被(人为)恢复或激活,**静止阻塞转入活跃阻塞**
>* 静止阻塞时等待的资源满足,**静止阻塞转入静止就绪**
>* 静止就绪被(人为)恢复或激活,**静止就绪转入活跃就绪**

### 进程的控制

内核是计算机系统硬件的首次延伸,是基于硬件的第一层软件扩充.为系统对进程进行控制和管理提供了环境.
进程的控制是由操作系统的内核中的原语实现的.
原语是由若干条机器指令组成.用于完成特定功能的程序段.原语执行时有原子特性.

### 进程间通讯

进程通讯是指各个进程交换信息的过程

#### 同步和互斥

##### 进程同步

进程间的同步是指系统中一些需要相互合作,协同工作的进程.这样的相互关系成为进程的同步.

##### 进程互斥

进程的互斥是指系统中多个进程因为争用临界资源而互相排斥执行.

##### 临界区管理

1. 有空则进
2. 无空则等
3. 有限等待
4. 让权等待

#### 信号量机制

信号量机制是一种有效的进程同步和互斥工具,主要有整形信号量,记录型信号量和信号量集机制.

整形信号量分为以下2类

1. 公用信号量 实现进程间的互斥.初始值为1或资源的数目
2. 私用信号量 实现进程间同步,初始值为0或者某个正数

信号量S

1. ${S}\ge{0}$时,S表示资源的可用数.
2. ${S}\lt{0}$时,S的绝对值表示阻塞队列中等待该资源的进程数

**PV操作**是实现进程同步与互斥的常用方法,P和V都是低级通讯原语.在执行期间不可分割.P操作表示申请一个资源,V操作表示释放一个资源.其定义如下

* **P操作** ${S}={S}-1$,若$S\ge0$,则P操作的进程继续执行,若$S\lt0$,则置该进程为阻塞状态.并将其插入阻塞队列.
* **V操作** ${S}={S}+1$,若$S\gt0$,则V操作的进程继续执行,若$S\le0$,则置从阻塞队列唤醒一个进程.并将其插入就绪队列.

![pv操作1.png](image/pv操作1.png)

**PV操作需要大量的例题来练习**!!!

### 管程

管程是一种同步机制.基本思路是集中管理进程提出的对资源的访问.管程提供了一种可以允许多进程安全,有效的共享抽象数据的机制.

### 进程调度

进程调度方式是指当有更高优先级的进程到来时如何分配CPU.调度方式分为可剥夺和不可剥夺两种.

#### 三级调度

* **高级调度** 高级调度又称长调度,作业调度或接纳调度.它决定处于输入池的那个后备作业可以调入主存做好运行的准备(禁止就绪).成为一个或者一组就绪状态的进程.一个作业只需要一次高级调度
* **中级调度** 中级调度又称中程调度或者对换调度.它决定处于交换区的那个就绪进程可以调入内存一边直接参与对CPU的竞争(静止就绪$\rightarrow$活跃就绪).同时,如果系统资源紧张,那些内存中处于阻塞状态的进程也会被移出至交换区(活跃阻塞$\rightarrow$静止阻塞),腾出空间.这相当与处于内存中的进程和处于磁盘交换区的进程对换了位置
* **低级调度** 又称短程调度或进程调度.它决定内存中的哪个就绪进程可以占用CPU(活跃就绪$\rightarrow$运行).低级调度最活跃,对系统的影响很大

#### 调度算法

* **先来先服务(First Coming  First Service FCFS)**: 按照作业提交或者进程就绪的先后顺序分配CPU,即总是将就绪队列头部的进程投入运行.特点是有利于长作业,不利于短作业;有利于CPU繁忙作业,不利于IO繁忙作业.主要用于宏观调度
* **时间片轮转**: 主要用于微观调度.目的是提高资源利用率.有固定时间片和可变时间片两种方式.
* **优先级调度**: 让每一个进程都拥有一个优先数.数值大的优先级高.分为静态优先级和动态优先级.
* **多级反馈调度**: 是时间片轮转算法和优先级算法的综合.优点是: 1.照顾了短进程以提高系统吞吐量,2.照顾了IO型进程获得了较好的IO设备利用率,3.不必估算进程的执行时间,动态调整优先级.

### 死锁

产生死锁的原因是因为资源竞争及进程推进顺序非法.

* 当系统中有多个进程所**共享的资源不足**以他们的需求时,将引起它们对资源的竞争导致死锁.
* 进程到推进的过程中**请求和释放资源的顺序不当**,也会导致进程死锁

产生死锁的四个条件是:**互斥条件,请求保持条件,不可剥夺条件和环路条件**

**计算进程并发所需的最小资源**的方法:

假设有n个进程,每个进程需要的资源数为S,问至少需要多少资源才能保证不发生死锁?

解题的方法就是把每个进程所需的最小资源数字减去1,然后相加,最后的结果再加1即可.用公式表示就是$$保证n个进程不发生死锁的最少资源数=(\sum_{i=1}^{n}({S}_{i}-1))+1$$

#### 死锁的处理

死锁的处理策略主要有4种: **鸵鸟策略,预防策略,避免策略,检测与解除思死锁**

##### 死锁预防

采用某种策略限制并发进程对资源的请求,**破坏死锁产生的4个必须条件之一**.使系统在任何时刻都不满足死锁的必要条件.

1. **预先静态分配法**: 破坏不可剥夺条件,预先分配所需资源,保证不等待资源.缺点是降低了对资源的利用率,降低了进程的并发程度,有时可能无法预先知道如何分配所需资源
2. **资源有序分配法**: 破坏了环路条件.把资源分类按照顺序排列,保证不形成环路.缺点是限制了进程对资源的请求,对资源的排序增加了系统开销

##### 死锁避免

不像死锁预防那样严格限制产生死锁的必要条件.而是使用算法避免死锁.死锁避免算法需要很大的系统开销.最著名的死锁避免算法是银行家算法
**银行家算法**对进程发出的没一个系统可以满足的资源请求命令加以检测,如果发现分配资源后系统进入不安全状态,则不予分配.若分配资源后系统仍处于安全状态.则实施分配. 
和思索预防策略比,死锁避免提高了资源的利用率,但分配资源的检测增加了系统的开销
**安全状态**是指对于进程$\{{P}_{1},{P}_{2},\dots,{P}_{n}\}$如果存在一个序列Q,系统按照Q指定的顺序来为每个进程分配资源.直到最大需求,使每个进程都可以顺序完成.则称Q为安全序列,否则称系统处于不安全状态

举例说明银行家算法

![银行家算法例题1.png](image/银行家算法例题1.png)

银行家算法的一个特点就是任何时候都要保证系统可用资源数大于等于0.在${T}_{0}$时刻.$R_{1},R_{2},R_{3}$三种资源已经分配了7,7,5个.那么在此时,剩余的资源数是$R_{1}=9-7=2,R_{2}=8-7=1,R_{3}=5-5=0$.现在开始解题:

* $R_3=0$意味着地一个进程不能消耗$R_3$资源.也就是说,第一个进程必须是$P_2$,答案在C和B选项之间.
* 第一个进程必须是$P_2$,那么系统先分配给$P_2$足够的资源,剩余资源状态是$R_1=2-1=1, R_2=1-1=0, R_3=0-0=0$.
* $P_2$运行完毕后,$P_2$资源会被释放,$R_1=1+2=3, R_2=0+2=2, R_3=0+1=1$
* 由于系统的剩余资源是$R_1=3, R_2=2, R_3=1$,所以无法满足$P_1$运行所需, 但能满足$P_4$运行所需,所欲选B.

##### 死锁检测

死锁检测方法对资源的分配不加限制,允许死锁的发生.但系统会定时运行一个死锁检测程序,判断是否发生了死锁,若检测到有死锁.,则设法加以解除.

##### 死锁解除

1. **资源剥夺法** 从一些进程那里强行剥夺足够数量的资源分配给死锁进程
2. **撤销进程法** 根据某种策略,逐个撤销死锁进程没,直至解除死锁为止

### 线程

传统进程的2个基本属性:

1. 可用有资源的独立单位
2. 可独立调度和分配的基本单位

由于进程在创建,测小和切换的过程中,系统需要较大的时空开销.所以导致系统中的进程不宜太多,进程的切换频率不宜太快,这就限制了并发程度的提高.引入线程后将传统进程的2个基本单位分开

* 线程作为调度和分配的基本单位
* 进程作为独立分配资源的单位
* 线程是进程中的一个实体,是被系统独立分配和调度的基本单位
* 线程和同属一个进程的其他线程共享进程拥有的全部资源

用户可以通过创建线程来完成任务,避免过大的时空开销.
线程也可称为轻型进程,传统进程称为重型进程.
线程可以创建另外一个线程,同一进程中的多个县城可以并发执行.
线程分为**用户级线程和内核支持线程**,用户级线程不依赖内核,其创建,撤销和切换都不利用系统调度来实现.内核支持线程存在与系统进程和用户进程中,依赖于内核,创建,撤销和切换都利用系统调度来实现.但无论是用户进程还是系统进程,其调度都是依赖于内核中的进程调度.

## 存储管理

### 基本概念

#### 存储器结构

存储管理的主要对象是主存/内存.常见的存储器结构是: 寄存器--[缓存]--主存--外存
存储管理的基本概念

* **虚拟地址**: 由于对于程序员来说,数据的存放地址是符号决定的,故称符号名地址或名地址.而把源程序的地址空间成为符号名地址空间或者名地址空间.虚拟地址是从0号单元开始编址,并顺序分配所有的符号名所对应的地址单元.虚拟地址不是主存中的实际地址,也称相对地址,程序地址,逻辑地址.
* **地址空间**: 程序中,由符号名组成的空间称为名空间.地址空间是以0为基址顺序进行编址的,相对地址组成的空间你成为逻辑空间,相对地址空间通过地址再定位机构转换到绝对地址空间,绝对地址空间也成为物理地址空间.
* **存储空间**: 逻辑地址空间简称地址空间,是逻辑地址的集合,物理地址空间简称存储空间,是物理地址的集合.

#### 地址重定向

地址重定向是指将逻辑地址变换成主存物理地址的过程.主要解决的是可执行文件中的地址和主存地址的对应关系,这个动作由系统的装入程序和地址重定位机构完成.地址重定位分为

1. **静态地址冲定位**:是指在程序装入主存时已经完成了逻辑地址到物理地址的变换,在程序的执行期间不会再发生变化.早期采用此方法较多,优点是无需硬件地址变换机构的支持.缺点是必须给作业分配一个连续的存储区域,在作业执行期间不能扩充存储空间,也不能在主存中移动,多个作业的数据难以共享.
2. **动态地址冲定位**:是指在程序运行期间完成逻辑地址到物理地址的变换.需要依赖硬件地址变换机构,比如基地址寄存器(BR).优点是 1.程序执行期间可以换出换入主存,以解决主存空间不足的问题; 2.可以在主存中移动,把主存中较小的碎片集中起来,充分利用空间; 3.不必给程序分配连续的主存空间,可以充分利用较小的主存块; 4.可以实现数据共享.

### 存储管理方案

#### 分区存储管理

把主存的用户区划分成若干个区域,每个区域给一个用户使用,并限定它们只能在自己的区域运行,这种主存分配方案就是分区存储管理方式.这种管理方式按照分区划分方式的不同分为**固定分区,可变分区和可重定位分区**.

* **固定分区**: 静态分区方式, 分区大小不可变,浪费严重.
* **可变分区**: 动态分区方式.主存划分的分区的个数和大小是可变的.可变风趣使用已分配表和未分配表记录分区的使用情况.可变分区有**最佳适应算法,最差适应算法,首次适应算法和循环首次适应算法**4种.无论任何一种算法,可变分区总是会导致主存中产生很多生成很多无法使用的小分区(外碎片).解决外碎片的方法就是定期向一个方向(比如低地址端)移动已分配的作业.使空闲的外碎片连成一片.但这势必导致所有的主存地址的重定向问题:

>1. **最佳适应算法**: 每次都寻找和当前需要的空间大小最接近的空闲分区切割一块出来分配.这样会导致快速的外碎片
>2. **最差适应算法**:每次都寻找最大的空白分区切割并装入作业,由于剩下的空白分区较大,所以不容易产生外碎片.
>3. **首次适应算法**: 每次都按照从主存的低地址到高地址的方向,使用地一个可以装入作业的空白空间进行切割.优点是由于地址的连续性,放作业完成后空间被释放时,更容易实现相邻空白空间的合并.
>4. **循环首次适应算法**: 按照从主存的低地址到高地址的方向,每次都从上一次刚分配的空间后的下一个空白分区开始寻找可以装入作业的空白分区.特点是避免总是使用(切割)同一个空白分区

* **可重定位风趣**: 者某个作业的请求的空间得不到满足时,就会要求所有正在使用的分区"靠拢",让空白的空间连成一片.能有效的避免空间浪费.但需要额外的系统成本.并且会导致所有的地址冲定位问题

#### 分区保护

1. 采用上界/下界寄存器保护 上界寄存器放入作业的装入地址,下界寄存器放入的是作业的结束地址
2. 采用基址/限长寄存器保护 基址寄存器放入的是作业的装入地址,限长寄存器装入的是作业的长度

### 分页存储管理

分页存储是为了有效的利用小的空白内存.原理是将一个进程的地址空间划分成若干大小相等的区域,称为页.相应的,把主存的空间也划分成与页大小相同的物理块,称为块或者页框.在为进程分配内存时,将进程中的若干页分别装入多个不相邻的块中.

